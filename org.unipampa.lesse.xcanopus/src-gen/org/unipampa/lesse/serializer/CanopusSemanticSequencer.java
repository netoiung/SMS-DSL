/*
 * generated by Xtext 2.14.0
 */
package org.unipampa.lesse.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.unipampa.lesse.canopus.CanopusPackage;
import org.unipampa.lesse.canopus.Criteria;
import org.unipampa.lesse.canopus.Disk;
import org.unipampa.lesse.canopus.Disk_IO_Counter;
import org.unipampa.lesse.canopus.Include;
import org.unipampa.lesse.canopus.LoadGenerator;
import org.unipampa.lesse.canopus.Memory;
import org.unipampa.lesse.canopus.MetricCollection;
import org.unipampa.lesse.canopus.MetricModel;
import org.unipampa.lesse.canopus.Model;
import org.unipampa.lesse.canopus.Monitor;
import org.unipampa.lesse.canopus.Monitoring;
import org.unipampa.lesse.canopus.SUT;
import org.unipampa.lesse.canopus.Threshold;
import org.unipampa.lesse.canopus.Transaction;
import org.unipampa.lesse.services.CanopusGrammarAccess;

@SuppressWarnings("all")
public class CanopusSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CanopusGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CanopusPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CanopusPackage.CRITERIA:
				sequence_Criteria(context, (Criteria) semanticObject); 
				return; 
			case CanopusPackage.DISK:
				sequence_Disk(context, (Disk) semanticObject); 
				return; 
			case CanopusPackage.DISK_IO_COUNTER:
				sequence_Disk_IO_Counter(context, (Disk_IO_Counter) semanticObject); 
				return; 
			case CanopusPackage.INCLUDE:
				sequence_Include(context, (Include) semanticObject); 
				return; 
			case CanopusPackage.LOAD_GENERATOR:
				sequence_LoadGenerator(context, (LoadGenerator) semanticObject); 
				return; 
			case CanopusPackage.MEMORY:
				sequence_Memory(context, (Memory) semanticObject); 
				return; 
			case CanopusPackage.METRIC_COLLECTION:
				sequence_MetricCollection(context, (MetricCollection) semanticObject); 
				return; 
			case CanopusPackage.METRIC_MODEL:
				sequence_MetricModel(context, (MetricModel) semanticObject); 
				return; 
			case CanopusPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case CanopusPackage.MONITOR:
				sequence_Monitor(context, (Monitor) semanticObject); 
				return; 
			case CanopusPackage.MONITORING:
				sequence_Monitoring(context, (Monitoring) semanticObject); 
				return; 
			case CanopusPackage.SUT:
				sequence_SUT(context, (SUT) semanticObject); 
				return; 
			case CanopusPackage.THRESHOLD:
				sequence_Threshold(context, (Threshold) semanticObject); 
				return; 
			case CanopusPackage.TRANSACTION:
				sequence_Transaction(context, (Transaction) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Criteria returns Criteria
	 *
	 * Constraint:
	 *     (value=EInt? threshold=[Threshold|EString]?)
	 */
	protected void sequence_Criteria(ISerializationContext context, Criteria semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Metric returns Disk
	 *     Disk returns Disk
	 *
	 * Constraint:
	 *     (name=EString threshold=[Threshold|EString]? disk_io_counter=[Disk_IO_Counter|EString]?)
	 */
	protected void sequence_Disk(ISerializationContext context, Disk semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Disk_IO_Counter returns Disk_IO_Counter
	 *
	 * Constraint:
	 *     (name=EString (counterDisk+=COUNTER_DISK counterDisk+=COUNTER_DISK*)? threshold=[Threshold|EString]? criteria=[Criteria|EString]?)
	 */
	protected void sequence_Disk_IO_Counter(ISerializationContext context, Disk_IO_Counter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Include returns Include
	 *
	 * Constraint:
	 *     (importURI=STRING name=ID)
	 */
	protected void sequence_Include(ISerializationContext context, Include semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CanopusPackage.Literals.INCLUDE__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CanopusPackage.Literals.INCLUDE__IMPORT_URI));
			if (transientValues.isValueTransient(semanticObject, CanopusPackage.Literals.INCLUDE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CanopusPackage.Literals.INCLUDE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIncludeAccess().getImportURISTRINGTerminalRuleCall_1_0(), semanticObject.getImportURI());
		feeder.accept(grammarAccess.getIncludeAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LoadGenerator returns LoadGenerator
	 *
	 * Constraint:
	 *     (name=ID hostname=EString ip=EString hardware=Hardware)
	 */
	protected void sequence_LoadGenerator(ISerializationContext context, LoadGenerator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CanopusPackage.Literals.LOAD_GENERATOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CanopusPackage.Literals.LOAD_GENERATOR__NAME));
			if (transientValues.isValueTransient(semanticObject, CanopusPackage.Literals.LOAD_GENERATOR__HOSTNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CanopusPackage.Literals.LOAD_GENERATOR__HOSTNAME));
			if (transientValues.isValueTransient(semanticObject, CanopusPackage.Literals.LOAD_GENERATOR__IP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CanopusPackage.Literals.LOAD_GENERATOR__IP));
			if (transientValues.isValueTransient(semanticObject, CanopusPackage.Literals.LOAD_GENERATOR__HARDWARE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CanopusPackage.Literals.LOAD_GENERATOR__HARDWARE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoadGeneratorAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLoadGeneratorAccess().getHostnameEStringParserRuleCall_4_0(), semanticObject.getHostname());
		feeder.accept(grammarAccess.getLoadGeneratorAccess().getIpEStringParserRuleCall_6_0(), semanticObject.getIp());
		feeder.accept(grammarAccess.getLoadGeneratorAccess().getHardwareHardwareEnumRuleCall_8_0(), semanticObject.getHardware());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Metric returns Memory
	 *     Memory returns Memory
	 *
	 * Constraint:
	 *     (name=EString threshold=[Threshold|EString]?)
	 */
	protected void sequence_Memory(ISerializationContext context, Memory semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetricCollection returns MetricCollection
	 *
	 * Constraint:
	 *     (metric+=Metric metric+=Metric*)
	 */
	protected void sequence_MetricCollection(ISerializationContext context, MetricCollection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetricModel returns MetricModel
	 *
	 * Constraint:
	 *     (name=ID (metricmodel+=MetricCollection metricmodel+=MetricCollection*)?)
	 */
	protected void sequence_MetricModel(ISerializationContext context, MetricModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (
	 *         (includes+=Include+ ((monitorings+=Monitoring+ loadGenerators+=LoadGenerator+) | loadGenerators+=LoadGenerator+)) | 
	 *         (((includes+=Include+ monitorings+=Monitoring+) | monitorings+=Monitoring+)? suts+=SUT+ loadGenerators+=LoadGenerator+) | 
	 *         (monitorings+=Monitoring+ loadGenerators+=LoadGenerator+) | 
	 *         loadGenerators+=LoadGenerator+
	 *     )?
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Monitor returns Monitor
	 *
	 * Constraint:
	 *     (hostname=EString? ip=EString? hardware=Hardware? sut=[SUT|ID]?)
	 */
	protected void sequence_Monitor(ISerializationContext context, Monitor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Monitoring returns Monitoring
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         projectLabel=EString 
	 *         projectAuthor=EString 
	 *         description=EString 
	 *         suts+=[SUT|ID]+ 
	 *         loadGenerators+=[LoadGenerator|ID]+
	 *     )
	 */
	protected void sequence_Monitoring(ISerializationContext context, Monitoring semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SUT returns SUT
	 *
	 * Constraint:
	 *     (name=ID hostname=EString? ip=EString? hardware=Hardware? type=SUTType?)
	 */
	protected void sequence_SUT(ISerializationContext context, SUT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Threshold returns Threshold
	 *
	 * Constraint:
	 *     value=EInt?
	 */
	protected void sequence_Threshold(ISerializationContext context, Threshold semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Metric returns Transaction
	 *     Transaction returns Transaction
	 *
	 * Constraint:
	 *     (name=EString threshold=[Threshold|EString]?)
	 */
	protected void sequence_Transaction(ISerializationContext context, Transaction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
